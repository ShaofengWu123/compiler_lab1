# 编译原理实验一实验报告

组内成员：  

- 徐姝玮 PE20110008
- 王晨     PE20060014
- 伍少枫 PE20110007

## 1.实验要求

​	针对以下文法$G_0$：
$$
\begin{aligned}
E \rightarrow \ & E\ > E \\
&| \ E\ < E  \\
&| \ number
\end{aligned}
$$
​	设计 YACC 描述文件并运行，使之能计算诸如 1 < 2 < 3 的表达式值为 True；而计算表达 式 1 < 5 > 3 的值也为 True。

## 2.实验思路

​	首先，在本报告中，我们假设不考虑只有一个数字的情况，只考虑连续的不等号运算结果。(由于实验要求并没有明确单个数字应该返回什么结果，在我们提交的实验代码中，保留了支持单个数字符号的情况，如果是非0的数字，将直接返回True）

​	由于原本的文法是同时有左递归和右递归的，而对于Yacc需要避免右递归<sup>[1]</sup>，因此先把文法改为左递归，形式如下：
$$
\begin{aligned}
T \rightarrow \ & E > number \\
&| \ E < number  \\
E \rightarrow \ & E > number \\
&| \ E < number  \\
&| \ number
\end{aligned}
$$
​	其中开始符号为$T$，这样设置的理由是保证不会出现单个数字的情况。

**注**：因为实验要求并没有明确单个数字应该返回什么结果，在我们提交的实验代码中，保留了支持单个数字符号的情况，如果是非0的数字，将直接返回True。

​	对于上述左递归文法，我们可以采用S属性定义完成属性计算，思路如下：由于每次进行比较，实际上是在使用**前面已分析过部分的连比式的最后一个数字与后面一个数字进行比较**，因此我们可以使用一个综合属性$val$来记录连比式的“值”(实际上就是结尾$number$的值)，从而与产生式中的$number.val$比较，比较结果如果合法，那么$number$将变成左部对应连比式的最后一个数字，因此将其$val$给左部即可；而如果比较不合法，那么可以打印`False`并直接结束分析，如果整个式子分析完成都没有结束程序，那么打印`True`即可。

## 3.源码分析说明	

​	实验的源代码文件以及相关文件包括以下文件：

- lab1.y：Yacc文件，其中包含文法和语义制导翻译属性栈实现代码。

- lab1.tab.c和lab1.tab.h：为Yacc生成的C源代码文件和头文件。

- lab1：gcc编译得到的可执行文件，在实验结果演示部分会使用。


​	下面主要对`lab1.y`文件内的源代码进行说明。

### 3.1.语义制导翻译的属性栈代码

​	下面展示了规则段的Yacc代码。规则段定义了number为一个终结符，并定义了文法以及翻译方案。

```c
%token number
%%
T : E '<' number {if($1 >= $3){printf("False\n");exit(1);}else{printf("True\n\n");}}
  | E '>' number {if($1 <= $3){printf("False\n");exit(1);}else{printf("True\n\n");}}
  ;
E : E '<' number  {if($1 >= $3){printf("False\n");exit(1);}else{$$ = $3;}}
  | E '>' number  {if($1 <= $3){printf("False\n");exit(1);}else{$$ = $3;}}
  | number {$$ = $1;}
  ; 
%%
```

​	对于产生式$E \rightarrow number$，按照我们的思路，只需要让$E.val$等于其末尾数字的值即可，因此属性栈操作为`$$ = $1`，实际上这一条语义动作可以省略，因为归约后属性栈栈顶值正好为$yylval$，不需要操作即可让$E.val = yylval$。

​	对于其他的产生式，以$E \rightarrow E_1 \ < number$为例，此时分析栈和属性栈图示如下：

![拓广分析栈](./拓广分析栈.png)

​	由分析栈图示可以知道，此时我们需要比较的属性为$\$1$和$\$3$，即前面已分析的连比式最后一个数字与其后第一个数字。对应两种情况为：

1. $E_1.val < number.val$，那么说明到目前为止没有出现错误，只需要让左部归约后的$val$等于$number.val$。
2. $E_1.val > number.val$，那么说明当前比较结果错误，无需继续分析，因此只需打印`False`并退出即可。

​	上述两种情况对应如下属性栈代码：

```c
{if($1 >= $3){printf("False\n");exit(1);}else{$$ = $3;}}
```

​	对于其他的产生式，思路相同，更改`if`的判断条件即可。

### 3.2.词法程序

​	Yacc文件内的`yylex()`函数为词法程序，其代码如下：

```c
int yylex()
{
   int c;
   while ( ( c=getchar() ) == ' ' ) ;
   if (isdigit(c)){
    ungetc( c, stdin );
   	scanf("%d", &yylval);   // value for token
   	return number;
   }
   if ( c=='\n' ) return 0; // return EOF -- $
   return c;
}
```

​	`yylex()`函数的主要作用是识别十进制单位数字并获取其对应的值，作为其属性存入`yylval`，为后续属性计算提供信息。另外还要识别一些特殊字符，例如跳过空格，并在遇到换行符时结束输入。对于其他的任何符号(包括'<','>'以及非法符号)，只需直接将符号返回给文法程序，由文法程序来判断是否合法。

​	我们也可以使用lex生成yylex( )代替我们这里自己写的`yylex()`，这样可以识别更复杂的输入情况，本实验使用我们自己写的词法分析器就可以满足实验要求了。

### 3.3.其他

​	其他部分代码包括定义段、用户程序、错误函数等，这些部分比较简单，可直接查看源代码，这里不做赘述。



## 4.实验结果演示

​	编写好Yacc源文件`lab1.y`后使用如下指令生成C语言文件。

```bash
bison -d lab1.y
```

​	然后使用如下命令使用gcc编译得到可执行文件`lab1`。

```bash
gcc -o lab1 lab1.tab.c
```

​	下图是完整的编译过程。

![编译](./编译.png)



​	得到可执行文件后，我们使用如下几个测试样例证明程序的正确性。

- 正确的输入：输入$4 \lt 5 \gt 3 \lt 6$，得到结果为`True`，结果正确。

  ![样例1](./样例1.png)

- 错误的输入：输入$4 \lt 5 \gt 3 \gt 6$，得到结果为`False`，结果正确。

  ![样例2](./样例2.png)

- 非法的输入：输入$1 << 2$，得到结果为`syntax error`，能够正常判断非法的输入。

  ![样例3](./样例3.png)

​	综上，使用Yacc构建出来的对应文法$G_0$的程序可以正确计算连比式的值。

## 5.实验总结

​	通过本次实验，主要熟悉了Yacc文件的组成、编写方法、编译方法以及原理，并且设计了连比式的左递归文法以及对应的连比式结果的翻译方案，利用Yacc构建了对应文法以及翻译方案的程序，并通过样例测试。这次实验加深了我们对于Yacc使用以及文法、翻译方案设计的理解。

## 6.组员贡献

伍少枫：完成语法制导定义设计以及源代码编写、测试，完成实验报告编写。

王晨：完成语法制导定义设计以及源代码编写、测试，完成ppt编写。

徐姝玮：完成汇报ppt制作。



## 7.参考

[1] lex yacc学习：https://www.jianshu.com/p/0e53c3b5de09

[2] 陈意云, 张昱. 编译原理[M]. 第三版. 高等教育出版社, 2014 :95-102.

[3] 2021课堂ppt
